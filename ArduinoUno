#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <RTClib.h>
#include <Keypad.h>
#include <Adafruit_Fingerprint.h>
#include <SoftwareSerial.h>



// Configuración del teclado matricial 4x4
const byte ROWS = 4; 
const byte COLS = 4; 
char keys[ROWS][COLS] = {
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};
byte rowPins[ROWS] = {9, 8, 7, 6}; 
byte colPins[COLS] = {5, 4, 3, 2}; 
Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

// Configuración del LCD I2C
LiquidCrystal_I2C lcd(0x27, 16, 2); // La dirección I2C puede variar. Asegúrate de que sea la correcta para tu módulo

// Configuración del RTC
RTC_DS1307 rtc;

// Configuración del sensor de huellas dactilares normal 
SoftwareSerial mySerial(13, 12); // RX, TX
Adafruit_Fingerprint finger = Adafruit_Fingerprint(&mySerial);


// Variables de estado
enum Estado { MONITORA, MENU_PRINCIPAL, INGRESAR, EGRESAR, CARGAR_HUELLA, BORRAR_HUELLA };
Estado estadoActual = MONITORA;
bool fromMonitora = false;
int admin_ID = -1; // Variable para almacenar el ID del administrador
int currentUserID = -1;
const int chipSelect = 10;  // Asegúrate de que este pin coincida con tu configuración

void setup() {
  lcd.init();
  lcd.backlight();
  Wire.begin(); // Inicializar I2C

  if (!rtc.begin()) {
    lcd.print("No RTC found!");
    while (1);
  }
  if (!rtc.isrunning()) {
    rtc.adjust(DateTime(F(__DATE__), F(__TIME__))); // Ajustar fecha/hora a la de compilación
  }

  mySerial.begin(57600); //comunicacion con el adafruit fingerprint
  Serial.begin(9600); //comunicacion con nodemcu

  // No es necesario llamar a begin(), la inicialización es implícita
  if (!finger.verifyPassword()) {
    lcd.print("No sensor found!");
    while (1);
  } else {
    lcd.print("Sensor iniciado");
    delay(2000);
    lcd.clear();
  }

  admin_ID = registrarAdministrador();
  lcd.clear();
  lcd.setCursor(0,0);
  lcd.print("Administrador");
  lcd.setCursor(0,1);
  lcd.print(" Cargado ");
  delay(1000);



}

void loop() {
  char key = keypad.getKey();
  DateTime now = rtc.now();

   switch (estadoActual) {
    case MONITORA:
      lcd.setCursor(0, 0);
      lcd.print("   MONITORA   ");
      lcd.setCursor(0, 1);
      lcd.print(now.day(), DEC);
      lcd.print('/');
      lcd.print(now.month(), DEC);
      lcd.print('/');
      lcd.print(now.year(), DEC);
      lcd.print(" ");
      lcd.print(now.hour(), DEC);
      lcd.print(':');
      lcd.print(now.minute(), DEC +"  ");

      if (key == '0') {
        estadoActual = MENU_PRINCIPAL;
        fromMonitora = true;
        lcd.clear();
      }
      break;

    case MENU_PRINCIPAL:
      lcd.setCursor(0, 0);
      lcd.print("Menu: A:In B:Eg ");
      lcd.setCursor(0, 1);
      lcd.print("C:Ca D:Bo 0:Back");

      if (key) {
        switch (key) {
          case 'A':
          case 'B':
          case 'C':
          case 'D':
            // Solicitar el ID de usuario una sola vez
            currentUserID = ingresarUsuarioID();
            if (currentUserID != -1) {
              // Asignar estado basado en la opción seleccionada
              switch (key) {
                case 'A':
                  estadoActual = INGRESAR;
                  ingresar();
                  break;
                case 'B':
                  estadoActual = EGRESAR;
                  egresar();
                  break;
                case 'C':
                  estadoActual = CARGAR_HUELLA;
                  cargarHuella();
                  break;
                case 'D':
                  estadoActual = BORRAR_HUELLA;
                  borrarHuella();
                  break;
              }
              lcd.clear();
            } else {
              estadoActual = MENU_PRINCIPAL;
              lcd.clear();
            }
            break;

          case '0':
            if (fromMonitora) {
              estadoActual = MONITORA;
              fromMonitora = false;
              lcd.clear();
            } else {
              estadoActual = MENU_PRINCIPAL;
            }
            break;

          default:
            lcd.clear();
            lcd.setCursor(0, 0);
            lcd.print("Invalid Option");
            delay(1000); // Retardo para ver la opción inválida
            lcd.clear();
            estadoActual = MENU_PRINCIPAL;
            break;
        }
      }
      break;

    // Otros casos como INGRESAR, EGRESAR, CARGAR_HUELLA, BORRAR_HUELLA
    // No necesitan solicitar el ID de usuario nuevamente.
  }
}

void ingresar() {
  lcd.setCursor(0, 0);
  lcd.print("Ingreso de usuario");
  lcd.setCursor(0, 1);
  lcd.print("ID: ");
  lcd.print(currentUserID);
  int currentHuella =leerHuella();
  if (currentHuella == currentUserID){
    lcd.clear();
    lcd.setCursor(0, 0);
    String txtConcat = generarCadenaConIDyHora(currentUserID);
    Serial.println(txtConcat + ";I");
    lcd.print("Ingreso existoso");
    delay(1000);
  }else{
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Huella No Cargada");
    lcd.setCursor(0,1);
    lcd.print("o no coincide id");
    delay(2000);
  }

  estadoActual = MONITORA;
  lcd.clear();
}

void egresar() {
  lcd.setCursor(0, 0);
  lcd.print("Engreso de usuario");
  lcd.setCursor(0, 1);
  lcd.print("ID: ");
  lcd.print(currentUserID);
  int currentHuella =leerHuella();
  if (currentHuella == currentUserID){
    lcd.clear();
    lcd.setCursor(0, 0);
    String txtConcat = generarCadenaConIDyHora(currentUserID);
    Serial.println(txtConcat + ";E");
    lcd.print("Engreso existoso");
    // aca deberia implementar la parte de armado de paquete o de guardado en sd 
    delay(1000);
  }else{
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Huella No Cargada");
    lcd.setCursor(0,1);
    lcd.print("o no coincide id");
    delay(2000);
  }

  estadoActual = MONITORA;
  lcd.clear();
}

void cargarHuella() {
  if (verificarAdministrador()) {
    lcd.setCursor(0, 0);
    lcd.print("Cargar Huella  ");
    lcd.setCursor(0, 1);
    lcd.print("ID: ");
    lcd.print(currentUserID);
    if (verificarIDExistente(currentUserID)){
    lcd.clear();
    lcd.setCursor(0,0);
    lcd.print("ID ya utilizado");
    delay(1000);
    }
    else{
    if (verificarHuella()) {
     lcd.clear();
     lcd.setCursor(0, 0);
     lcd.print("Huella ya cargada");
     delay(2000);
     estadoActual = MONITORA;
     lcd.clear();
  } else {
     lcd.clear();
     lcd.setCursor(0, 0);
     lcd.print("Cargando huella");
     registrarUser(currentUserID);
     delay(2000);
     estadoActual = MONITORA;
     lcd.clear();
    }
    }
    estadoActual = MONITORA;
    lcd.clear();
  } else {
    estadoActual = MENU_PRINCIPAL;
    lcd.clear();
  }
}

void borrarHuella() {
  if (verificarAdministrador()) {
    lcd.setCursor(0, 0);
    lcd.print("Borrar Huella  ");
    lcd.setCursor(0, 1);
    lcd.print("ID: ");
    lcd.print(currentUserID);

    if (verificarIDExistente(currentUserID)){
    lcd.clear();
    lcd.setCursor(0,0);
    lcd.print("usuario numero:       ");
    lcd.setCursor(0,1);
    lcd.print(currentUserID);
    BorrarUserHuella(currentUserID);
    delay(1000);
    estadoActual = MONITORA;
    lcd.clear();
    }else{
    lcd.clear();
    lcd.setCursor(0,0);
    lcd.print("ID no cargado  ");
    lcd.setCursor(0,1);
    lcd.print("   en memoria   ");
    delay(3000); 
    }
    estadoActual = MONITORA;
    lcd.clear();
  } else {
    estadoActual = MENU_PRINCIPAL;
    lcd.clear();
  }
}

bool verificarAdministrador() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Verif. Admin:");
  delay(1000);
  int id = leerHuella(); // Función que devuelve el ID de la huella leída
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Admin ID: ");
  lcd.print(admin_ID);
  delay(1000);
  if (id == admin_ID ) {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Acceso concedido:");
    delay(1000);
    return true;
  } else {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Acceso Denegado");
    delay(2000);
    return false;
  }
}

int leerHuella() {
  lcd.clear();
  lcd.print("Coloca el dedo");
  while (finger.getImage() != FINGERPRINT_OK) {
    // Espera hasta que se coloque el dedo en el sensor
  }

  if (finger.image2Tz() != FINGERPRINT_OK) {
    lcd.clear();
    lcd.print("Error en imagen");
    return -1;
  }

  if (finger.fingerSearch() != FINGERPRINT_OK) {
    lcd.clear();
    lcd.print("No coincidencia");
    return -1;
  }

  // Devuelve el ID de la huella encontrada
  return finger.fingerID;
}


void BorrarUserHuella(int id) {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Borrando huella");
  lcd.setCursor(0, 1);
  lcd.print("ID: ");
  lcd.print(id);
  
  int result = finger.deleteModel(id);

  delay(2000); // Pausa para mostrar el mensaje inicial
  
  lcd.clear();
  lcd.setCursor(0, 0);

  if (result == FINGERPRINT_OK) {
    lcd.print("Huella borrada");
    lcd.setCursor(0, 1);
    lcd.print("con Exito.");
  } else if (result == FINGERPRINT_PACKETRECIEVEERR) {
    lcd.print("Error al recibir");
    lcd.setCursor(0, 1);
    lcd.print("el paquete.");
  } else if (result == FINGERPRINT_BADLOCATION) {
    lcd.print("Error de ubicación.");
  } else if (result == FINGERPRINT_FLASHERR) {
    lcd.print("Error de memoria");
    lcd.setCursor(0, 1);
    lcd.print("flash.");
  } else {
    lcd.print("Error desconocido.");
  }
}

int registrarAdministrador() {
  lcd.clear();
  lcd.print("Coloque dedo");

  // Primero, guarda la huella en la memoria del sensor con ID 0
  bool success = enrollFinger(0); // ID 0 para el administrador

  if (success) {
    lcd.clear();
    lcd.print("Huella guardada ");
    delay(1000);
    // Luego, leer la huella del administrador y guardar el ID
    lcd.print("Leer admin");
    delay(1000);
    int admin_ID = leerHuella(); 
    lcd.clear();

    if (admin_ID != -1) {
      lcd.print("Admin ID: ");
      lcd.print(admin_ID);
      return admin_ID;
    } else {
      lcd.print("No coincidencia");
    }
  } else {
    lcd.clear();
    lcd.print("Error al guardar");
  }

  delay(2000); // Espera antes de intentar otra operación
  lcd.clear();
  return admin_ID;
}

bool enrollFinger(int id) {
  int p = -1;
  lcd.setCursor(0, 0);
  lcd.print("Coloca el dedo");
  while (p != FINGERPRINT_OK) {
    p = finger.getImage();
    if (p == FINGERPRINT_OK) {
      lcd.clear();
      lcd.setCursor(0, 0);
      lcd.print("Imagen tomada");
      delay(300);
    } else if (p == FINGERPRINT_NOFINGER) {
      lcd.setCursor(0, 1);
      lcd.print(".");
    } else if (p == FINGERPRINT_PACKETRECIEVEERR) {
      lcd.setCursor(0, 1);
      lcd.print("Comm error");
      return false;
    } else if (p == FINGERPRINT_IMAGEFAIL) {
      lcd.setCursor(0, 1);
      lcd.print("Imagen fallida");
      return false;
    }
  }

  p = finger.image2Tz(1);
  if (p != FINGERPRINT_OK) {
    lcd.setCursor(0, 1);
    lcd.print("Error");
    return false;
  }

  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Remueve el dedo ");
  delay(2000);
  p = 0;
  while (p != FINGERPRINT_NOFINGER) {
    p = finger.getImage();
  }

  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Coloca el dedo");
  while (p != FINGERPRINT_OK) {
    p = finger.getImage();
    if (p == FINGERPRINT_OK) {
      lcd.clear();
      lcd.setCursor(0, 0);
      lcd.print("Imagen tomada ");
      delay(300);
    } else if (p == FINGERPRINT_NOFINGER) {
      lcd.setCursor(0, 1);
      lcd.print(".");
    } else if (p == FINGERPRINT_PACKETRECIEVEERR) {
      lcd.setCursor(0, 1);
      lcd.print("Comm error");
      return false;
    } else if (p == FINGERPRINT_IMAGEFAIL) {
      lcd.setCursor(0, 1);
      lcd.print("Imagen fallida");
      return false;
    }
  }

  p = finger.image2Tz(2);
  if (p != FINGERPRINT_OK) {
    lcd.setCursor(0, 1);
    lcd.print("Error");
    return false;
  }

  p = finger.createModel();
  if (p != FINGERPRINT_OK) {
    lcd.setCursor(0, 1);
    lcd.print("Error");
    return false;
  }

  p = finger.storeModel(id);
  if (p == FINGERPRINT_OK) {
    lcd.setCursor(0, 1);
    //lcd.print("Guardada!");
    delay(300);
    return true;
  } else {
    lcd.setCursor(0, 1);
    lcd.print("Error");
    return false;
  }
}

// Función para pedir el ID del usuario
int ingresarUsuarioID() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Ingresa User ID:");
  lcd.setCursor(0, 1);
  String userIDStr = "";
  char key = keypad.getKey();
  while (key != '#') {
    if (key && isDigit(key)) {
      userIDStr += key;
      lcd.print(key);
    }
    key = keypad.getKey();
  }

  int userID = userIDStr.toInt();
  if (userID >= 1 && userID <= 99) {
    return userID;
  } else {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("ID invalido");
    delay(2000);
    return -1;
  }
}

bool verificarHuella() {
  int huellaID = leerHuella();
  
  if (huellaID == -1) {
    // No se encontró ninguna coincidencia o hubo un error en la lectura
    return false;
  } else {
    // La huella ya está cargada
    return true;
  }
}

void registrarUser(int User_ID) {
  lcd.clear();
  lcd.setCursor(0,0);
  lcd.print("Coloque dedo");

  // Primero, guarda la huella en la memoria del sensor con ID 0
  bool success = enrollFinger(User_ID); // ID 0 para el administrador

  if (success) {
    lcd.clear();
    lcd.setCursor(0,0);
    lcd.print("Huella guardada ");
    delay(1000);
  } else {
    lcd.clear();
    lcd.setCursor(0,0);
    lcd.print("Error al guardar");
  }

  delay(2000); // Espera antes de intentar otra operación
  lcd.clear();
}

bool verificarIDExistente(int id) {
  for (int i = 1; i <= 99; i++) {
    if (i == id && finger.loadModel(i) == FINGERPRINT_OK) {
      return true; // El ID ya está en uso
    }
  }
  return false; // El ID no está en uso
}

String obtenerHoraActual() {
  DateTime now = rtc.now();  // Obtener la hora actual del RTC

  // Formatear la fecha y hora en una cadena
  char buffer[20];
  snprintf(buffer, sizeof(buffer), "%02d-%02d-%02d %02d:%02d:%02d",
           now.year(), now.month(), now.day(),
           now.hour(), now.minute(), now.second());

  return String(buffer);
}

String generarCadenaConIDyHora(int id) {
  String horaActual = obtenerHoraActual();
  
  char idBuffer[3];
  snprintf(idBuffer, sizeof(idBuffer), "%02d", id);

  String resultado = String(idBuffer) + ";" + horaActual;
  
  return resultado;
}

//falta agregar un check de mensaje recibido entre el uno y el nodemcu
//falta agregar/cambiar poder agregar un administrador

